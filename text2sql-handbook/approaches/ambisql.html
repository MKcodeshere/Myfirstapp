<!DOCTYPE html>
<html lang="en">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Building Interactive Text-to-SQL with AmbiSQL: Ambiguity Detection and Resolution | Text-to-SQL Handbook</title>

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Custom CSS -->
  <link rel="stylesheet" href="../assets/css/main.css?v=15">

  <!-- Prism.js for code highlighting -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>

<nav class="navbar">
    <div class="container">
      <div class="flex items-center justify-between py-4">
        <a href="../index.html" class="text-2xl font-bold text-blue-600">
          Text2SQL<span class="text-gray-200">Hub</span>
        </a>
        <div class="hidden md:flex items-center space-x-8">
          <a href="../index.html" class="nav-link">Home</a>
          <a href="../what-is-text2sql.html" class="nav-link">What is Text-to-SQL?</a>
          <a href="../approaches.html" class="nav-link active">Approaches</a>
          <a href="../about.html" class="nav-link">About</a>
          <a href="../consulting.html" class="btn-primary">Get In Touch</a>
        </div>
      </div>
    </div>
  </nav>


  <!-- Article Header -->
  <section class="article-header">
    <div class="container">
      <div class="max-w-4xl mx-auto">
        <a href="../approaches.html" class="text-white opacity-75 hover:opacity-100 mb-6 inline-block">‚Üê Back to All Approaches</a>

        <h1 class="text-3xl md:text-4xl font-bold mb-6">
          Building Interactive Text-to-SQL with AmbiSQL: Ambiguity Detection and Resolution
        </h1>

        <!-- Article Meta Info -->
        <div class="article-meta">
          <span>üìÖ October 29, 2025</span>
          <span>‚è±Ô∏è 8 min read</span>
          <span class="difficulty-badge difficulty-advanced">advanced</span>
        </div>
      </div>
    </div>
  </section>



  <!-- Article Content -->
  <div class="container py-12">
    <div class="article-content">
      
      <!-- Intro -->
      <section>
        <p class="text-xl font-semibold text-gray-200 mb-6">
          Implementing Alibaba‚Äôs research paper approach that uses clarification questions to resolve query ambiguities and improve SQL generation accuracy to 92.5%
        </p>
      </section>
    
      
    <div class="my-8">
        <img src="../assets/images/ambisql/intro.png" alt="Ambi sql introduction" class="w-full rounded-lg shadow-lg">
        <p class="text-center text-sm text-secondary mt-2">Image Generated by Author Using AI</p>
      </div>

      <h3><strong>Building Interactive Text-to-SQL with AmbiSQL: Ambiguity Detection and Resolution</strong></h3>
<h4><strong>Implementing Alibaba‚Äôs research paper approach that uses clarification questions to resolve query ambiguities and improve SQL generation accuracy to 92.5%</strong></h4>

<p>
While Large Language Models (LLMs) are great at converting natural language to SQL, they often fail because of ambiguous user questions. A system can be perfectly capable of writing complex code, but if it misunderstands what you‚Äôre asking for, the result will be wrong. This gap between user intent and the LLM‚Äôs interpretation is a major obstacle for modern Text-to-SQL systems.
</p>
<p>
The problem? <strong>Ambiguity</strong>. When I asked ‚ÄúHow many drivers were born after the end of the Vietnam War?‚Äù, the system had to guess: Did I mean April 30, 1975, or just the year 1975? Which database column represents ‚Äúranked‚Äù?
</p>
<p>
Researchers from Alibaba Group built <strong>AmbiSQL</strong> to solve this. Instead of guessing, it detects ambiguities and asks you clarifying questions before generating SQL. Their results showed accuracy jumping from 42.5% to 92.5% on ambiguous queries.
</p>
<p>
I wanted to test this myself, but unfortunately, I cannot access the Alibaba model used in this AmbiSQL code, so I have updated their code and built my own frontend to access it from anywhere.
</p>
<p>
Before the demo, let‚Äôs understand their architecture.
</p>
<h3><strong>Understanding the AmbiSQL Architecture</strong></h3>
<p>
<strong>AmbiSQL</strong> works in two distinct stages.
</p>
<h4><strong>Stage 1: Ambiguity Identification</strong></h4>
<p>
When you submit a query, the system scans it for ambiguous phrases using a comprehensive taxonomy. This taxonomy covers two dimensions:
</p>
<ul>
<li><strong>DB-related ambiguity</strong>: Issues with database schema or content references. For example, ‚Äúoldest user‚Äù could mean age or registration date. ‚ÄúNew York City‚Äù versus ‚ÄúNYC‚Äù in the database. Missing keywords that leave SQL operations unclear.</li>
<li><strong>LLM-related ambiguity</strong>: Problems with reasoning and external knowledge. When should the system query the database versus using inference? What happens when temporal references like ‚Äúend of Vietnam War‚Äù need exact dates? How to handle ambiguous geographical boundaries?\[1\]</li>
<p>
</ul>
</p>
<p>
The system uses in-context learning with carefully constructed prompts. It doesn‚Äôt need expensive training datasets. Instead, it feeds the LLM explicit ambiguity definitions, taxonomy descriptions, and examples to guide detection.
      <div class="my-8">
        <img src="../assets/images/ambisql/figure1.png" alt="ambisql Architecture Diagram" class="w-full rounded-lg shadow-lg">
        <p class="text-center text-sm text-secondary mt-2">Image from <a href="https://www.arxiv.org/pdf/2510.04618" target="_blank" class="text-blue-600 hover:underline">Alibaba Research Paper</a></p>
      </div>
<strong>Figure 1</strong> from the research paper illustrates this complete workflow. The left side shows Stage 1 with ambiguity detection identifying the problematic phrases, then the clarification question generation module creates targeted multiple-choice options with database context.
</p>
<h4><strong>Stage 2: Iterative Refinement</strong></h4>
<p>
After you answer the clarification questions, AmbiSQL stores your preferences in a tree structure. Each branch represents an ambiguity subcategory. Leaf nodes store your specific choices.
      <div class="my-8">
        <img src="../assets/images/ambisql/figure2.png" alt="ambisql workflow Diagram" class="w-full rounded-lg shadow-lg">
        <p class="text-center text-sm text-secondary mt-2">Image from <a href="https://www.arxiv.org/pdf/2510.04618" target="_blank" class="text-blue-600 hover:underline">Alibaba Research Paper</a></p>
      </div>
<strong>Figure 2</strong> shows this preference tree. When ambiguities like ‚Äúunclear schema reference‚Äù or ‚Äúambiguous temporal/spatial scope‚Äù are detected, your answers get stored in corresponding leaf nodes. If you selected ‚Äúposition column,‚Äù it goes under the unclear schema reference branch. If you chose ‚Äú1975‚Äì12‚Äì31,‚Äù it goes under an ambiguous temporal scope.
</p>
<p>
You can also add extra constraints. ‚ÄúI also need the drivers to be German.‚Äù
</p>
<p>
The system combines your original query with clarifications and constraints into a refined query. Then it checks again for new ambiguities. If none exist, it passes everything to the text-to-SQL system for final SQL generation.
</p>
<p>
If semantic contradictions occur, like changing your preference from ‚Äúposition‚Äù to ‚Äúrank‚Äù the LLM automatically updates stored preferences using conflict resolution examples.
</p>
<p>
<strong>The Performance Numbers Tell the Story</strong>
</p>
<p>
The researchers tested AmbiSQL on 40 ambiguous queries from BIRD and TAG benchmarks. They measured using exact match accuracy‚Ää‚Äî‚Äädoes the generated SQL match the ground truth?
</p>
<p>
<strong>Table 1</strong> shows the dramatic improvements:
      <div class="my-8">
        <img src="../assets/images/ambisql/table1.png" alt="ambisql table1" class="w-full rounded-lg shadow-lg">
        <p class="text-center text-sm text-secondary mt-2">Image from <a href="https://www.arxiv.org/pdf/2510.04618" target="_blank" class="text-blue-600 hover:underline">Alibaba Research Paper</a></p>
      </div>
That 65 percentage point jump on TAG samples is remarkable. TAG queries involve complex reasoning, external knowledge, and multi-table joins. Without ambiguity resolution, systems frequently fail when they need external knowledge with limited context.\[1\]
</p>
<p>
For BIRD samples, the improvement from 75% to 100% shows AmbiSQL handles both complex and straightforward ambiguous queries effectively.
</p>
<p>
<strong>Table 2</strong> breaks down detection accuracy across ambiguity types:
      <div class="my-8">
        <img src="../assets/images/ambisql/table2.png" alt="ambisql table2" class="w-full rounded-lg shadow-lg">
        <p class="text-center text-sm text-secondary mt-2">Image from <a href="https://www.arxiv.org/pdf/2510.04618" target="_blank" class="text-blue-600 hover:underline">Alibaba Research Paper</a></p>
      </div>
DB-related ambiguities show higher recall but lower precision‚Ää‚Äî‚Ääthe system catches most instances with slight over-detection. LLM-related ambiguities show higher precision but lower recall‚Ää‚Äî‚Äämore conservative, prioritizing accuracy.
</p>
<p>
Some subcategories achieved perfect scores:
</p>
<ul>
<li>Missing SQL-related keywords: 100% F1-score</li>
<p>
</ul>
</p>
<ul>
<li>Conflicting knowledge: 100% F1-score</li>
<p>
</ul>
</p>
<h3><strong>My Experience Testing AmbiSQL</strong></h3>
<p>
When I tried setting up the original AmbiSQL from their Official GitHub, I hit a roadblock immediately. The system uses XiYan-SQL (specifically XGenerationLab/XiYanSQL-QwenCoder-32B-2504) from ModelScope. But ModelScope is only accessible from China and Singapore, not from other Countries.
</p>
<p>
So I modified the implementation. I updated the system to use GPT-4.1 instead of the original XiYanSQL model, which might not 100% AmbiSQL because Alibaba finetuned that model to be efficient in SQL generation. But this let me test the system internationally without geographic restrictions.
</p>
<p>
Then I built a Streamlit app with the modified AmbiSQL server as the backend. The frontend provides a clean interface where users can input queries, see detected ambiguities, answer clarification questions, and view the generated SQL.
</p>
<p>
I tested it with the classic ambiguous query: ‚Äú<strong>How many drivers born after the end of the Vietnam War have been ranked 2?‚Äù</strong>
</p>
      <div class="my-8">
        <img src="../assets/images/ambisql/demo.gif" alt="ambisql demo gif" class="w-full rounded-lg shadow-lg">
        <p class="text-center text-sm text-secondary mt-2">Image by Author</a></p>
      </div>
<p>
Image by Author
</p>
<h3><strong>What Happens in this Demo</strong></h3>
<ul>
<li><strong>First</strong>, I enter the query in the input field and select the Formula One database.</li>
<li><strong>Second</strong>, AmbiSQL detects two ambiguities and presents clarification questions:</li>
<li>Question 1 asks: ‚ÄúDo you mean drivers born after the end day or the end year of the Vietnam War?‚Äù It provides context: the end day was April 30, 1975, and the end year was 1975\. I select ‚Äúend year.‚Äù</li>
<li>Question 2 asks: ‚ÄúWhich column should determine driver ranking?‚Äù It shows many options with database schema descriptions. I select the <strong>position column from the results table.</strong></li>
<li><strong>Then</strong> I add an extra constraint: ‚ÄúI need the drivers to be German.‚Äù</li>
<li>Submitted my Clarifications, then the system refines my query, checks for new ambiguities (none found), and generates the SQL.</li>
<li>The final SQL appears with the correct temporal filter (year 1975), the right column reference (position), and my additional nationality constraint (German drivers).</li>
<li>The system then executes the query and returns: 5 drivers</li>
<p>
</ul>
</p>
<p>
Without the clarification step, the base text-to-SQL system used the exact date (April 30, 1975\) instead of the year, or mapped ‚Äúranked‚Äù to the wrong column, and it produced incorrect results ( 13 drivers).
</p>
<h3><strong>Why This Matters More Than You Think</strong></h3>
<p>
Here‚Äôs what testing AmbiSQL taught me: <strong>the accuracy problem in text-to-SQL isn‚Äôt about better language models</strong>. It‚Äôs about recognizing when human language is inherently ambiguous and asking for help.
</p>
<p>
Most text-to-SQL systems try to be fully automated. They guess at interpretations or generate dozens of candidate queries, hoping one matches what you meant. Both approaches fail in production, where incorrect queries lead to bad decisions.\[
</p>
<p>
Think about a business analyst querying sales data. They ask, ‚ÄúShow me top customers from the last quarter.‚Äù Does ‚Äútop‚Äù mean highest revenue, most orders, or largest order value? Does ‚Äúlast quarter‚Äù mean Q4 of last year or the most recent complete quarter? Get either wrong and the business makes decisions based on wrong data.
</p>
<p>
AmbiSQL embraces human interaction as a must-needed feature for users to trust the text2sql System. It lets users start with natural, ambiguous questions. Then it guides them through targeted clarification. The multiple-choice format means you never need SQL knowledge. You just select what you meant.
</p>
<p>
This builds <strong>trust</strong>. When the system shows it understands the ambiguity, you gain confidence the final SQL will match your intent. That‚Äôs critical for production environments.
</p>
<h3><strong>The Bigger Picture</strong></h3>
<p>
Current text-to-SQL benchmarks underestimate this problem. They provide one ground-truth SQL per question and use exact match metrics. If your SQL doesn‚Äôt match exactly, you get zero credit‚Ää‚Äî‚Ääeven if your interpretation was perfectly valid for an ambiguous question.\[6\]\[1\]
</p>
<p>
This systematically underestimates system capabilities. A model might generate completely valid SQL representing one reasonable interpretation but score zero.
</p>
<p>
AmbiSQL can identify ambiguous questions in existing benchmarks and generate multiple valid interpretations. This makes evaluation fairer and more accurate.\[1\]
</p>
<h3><strong>What‚Äôs Next</strong></h3>
<p>
My modified version proves you can run AmbiSQL internationally with OpenAI models instead of region-locked alternatives. The core ambiguity detection and resolution mechanisms work just as well with GPT-4.1.
</p>
<p>
I‚Äôm planning to extend this further. Some ideas:
</p>
<ul>
<li><strong>Proactive ambiguity prevention</strong>: Instead of detecting ambiguities after submission, anticipate them based on database characteristics. If a database has both registration\_date and birth\_date columns, automatically clarify temporal references in ‚Äúoldest‚Äù queries.</li>
<li><strong>Learning user patterns</strong>: Store preferences over time. If you consistently prefer certain interpretations for recurring ambiguity types, default to those while still allowing overrides.</li>
<li><strong>Multi-database support</strong>: Test across different database types (PostgreSQL, MySQL, MongoDB) to see how ambiguity patterns differ.</li>
<p>
</ul>
</p>
      <!-- Try It Yourself -->
      <section class="consulting-cta p-8 md:p-12 rounded-2xl my-12">
        <h2 class="text-white text-center mb-4">Try It Yourself</h2>
        <p class="text-xl text-center mb-8 opacity-90">
          Want to see AmbiSQL in action? The complete implementation is available on GitHub with setup instructions for the formula_1 database.
        </p>
        <div class="flex justify-center gap-4">
          <a href="https://github.com/MKcodeshere/AmbiSQL--International_Variant" target="_blank" class="btn-primary text-blue-600 hover:bg-gray-800">
            View on GitHub ‚Üí
          </a>
        </div>
      </section>

<p>
For anyone building text-to-SQL systems, here‚Äôs my advice: <strong>don‚Äôt try to eliminate ambiguity through better prompting or bigger models</strong>. Embrace it. Build systems that recognize when they‚Äôre uncertain and ask users for clarification. That‚Äôs not a limitation. That‚Äôs how you build systems people actually trust.
</p>
<p>
The 50 percentage point accuracy improvement AmbiSQL achieves isn‚Äôt just a benchmark number. It‚Äôs the difference between a system that occasionally works and one you can rely on for critical business decisions. And that difference comes from one simple insight: when in doubt, ask \!\!
</p>
      <!-- Resources -->
      <section>
        <h2>Resources</h2>
        <ul>
          <li><strong>Alibaba Research Paper:</strong> <a href="https://www.arxiv.org/pdf/2510.04618" target="_blank" class="text-blue-600 hover:underline">Ambisql from Alibaba</a></li>
          <li><strong>GitHub Repository:</strong> <a href="https://github.com/JustinzjDing/AmbiSQL" target="_blank" class="text-blue-600 hover:underline">Github Repo from Alibaba, Models are Accessible only from China/singapore</a></li>
        </ul>
      </section>
    </div>
  </div>


</body>
</html>
