<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>How I Built a Text-to-SQL System Without Vector Databases Using SQL Probes | Text-to-SQL Handbook</title>

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Custom CSS -->
  <link rel="stylesheet" href="../assets/css/main.css?v=14">

  <!-- Prism.js for code highlighting -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>

  <!-- Navigation -->
  <nav class="navbar">
    <div class="container">
      <div class="flex items-center justify-between py-4">
        <a href="../index.html" class="text-2xl font-bold text-blue-600">
          Text2SQL<span class="text-gray-200">Hub</span>
        </a>
        <div class="hidden md:flex items-center space-x-8">
          <a href="../index.html" class="nav-link">Home</a>
          <a href="../what-is-text2sql.html" class="nav-link">What is Text-to-SQL?</a>
          <a href="../approaches.html" class="nav-link active">Approaches</a>
          <a href="../about.html" class="nav-link">About</a>
          <a href="../consulting.html" class="btn-primary">Get In Touch</a>
        </div>
      </div>
    </div>
  </nav>

  <!-- Article Header -->
  <section class="article-header">
    <div class="container">
      <div class="max-w-4xl mx-auto">
        <a href="../approaches.html" class="text-white opacity-75 hover:opacity-100 mb-6 inline-block">‚Üê Back to All Approaches</a>

        <h1 class="text-3xl md:text-4xl font-bold mb-6">
          How I Built a Text-to-SQL System Without Vector Databases Using SQL Probes
        </h1>

        <!-- Article Meta Info -->
        <div class="article-meta">
          <span>üìÖ January 26, 2025</span>
          <span>‚è±Ô∏è 18 min read</span>
          <span class="difficulty-badge difficulty-advanced">advanced</span>
        </div>
      </div>
    </div>
  </section>

  <!-- Article Content -->
  <div class="container py-12">
    <div class="article-content">

      <!-- Intro -->
      <section>
        <p class="text-xl font-semibold text-gray-200 mb-6">
          How active database exploration with SQL Probes achieves 85% accuracy without embeddings, vector stores, or complex infrastructure
        </p>
      </section>

      <!-- Hero Image -->
      <div class="my-8">
        <img src="../assets/images/sql-probes/intro.png" alt="SQL Probes Introduction" class="w-full rounded-lg shadow-lg">
        <p class="text-center text-sm text-secondary mt-2">Image Generated by Author Using AI</p>
      </div>

      <!-- The Vector Database Problem -->
      <section>
        <h2>The Vector Database Problem</h2>
        <p>
          I got tired of the complexity in modern Text-to-SQL systems. Every tutorial starts with "First, set up your vector database‚Ä¶" Then you need to set up metadata extraction from the database or data platform, embedding pipelines, similarity search, and constant re-indexing when schemas change.
        </p>
        <p>
          <strong>Here's the real issue:</strong> Traditional approaches treat database information as static context. Everything gets pre-embedded, pre-indexed, and frozen in time. But that's not how database experts work.
        </p>
        <p>
          When you ask an experienced analyst to query an unfamiliar database, they don't just read documentation. They <strong>explore</strong>. They run test queries. They check data formats. They discover relationships through interaction.
        </p>
        <p>
          I wanted to teach AI to do the same.
        </p>
        <p>
          I found the <strong>SDE-SQL</strong> (Self-Driven Exploration SQL) research paper. The idea is simple but powerful: instead of guessing based on semantic similarity from a vector database, let the LLM actively query the database with targeted <strong>SQL Probes</strong>. This way, it learns the structure, data distribution, and relationships before generating the final SQL.
        </p>
        <p>
          <strong>No vector database. No embeddings. Just SQL exploring SQL.</strong>
        </p>
        <p>
          I built it. Here's what happened.
        </p>
      </section>

      <!-- SQL Probes: How They Work -->
      <section>
        <h2>SQL Probes: How They Work</h2>
        <p>
          The SDE-SQL framework uses a novel approach. The LLM doesn't just generate SQL ‚Äî it <strong>explores the database first</strong> using specialized queries called <strong>SQL Probes</strong>. Think of these as reconnaissance missions: small, targeted queries that gather intelligence before the main operation.
        </p>
      </section>

      <div class="my-8">
        <img src="../assets/images/sql-probes/architecture.png" alt="SDE-SQL Complete Workflow" class="w-full rounded-lg shadow-lg">
        <p class="text-center text-sm text-secondary mt-2">Figure 1 from the research paper shows the complete workflow, with exploration integrated throughout both generation and refinement stages.</p>
      </div>

      <section>
        <p>
          The beauty of this approach? SQL itself becomes the exploration tool. Instead of building complex embedding pipelines and vector indices, we use what databases already do best ‚Äî answering queries quickly and precisely.
        </p>
      </section>

      <!-- The Tree-Based Strategy -->
      <section>
        <h2>The Tree-Based Strategy</h2>
        <p>
          SDE-SQL breaks natural language queries into two parts:
        </p>
        <ul>
          <li><strong>Target:</strong> What you want to retrieve (the SELECT clause)</li>
          <li><strong>Conditions:</strong> Constraints on the data (WHERE, GROUP BY, HAVING clauses)</li>
        </ul>
      </section>

      <div class="my-8">
        <img src="../assets/images/sql-probes/tree-condition.png" alt="Tree-based Exploration Strategy" class="w-full rounded-lg shadow-lg">
        <p class="text-center text-sm text-secondary mt-2">Figure 3 from the paper shows the tree-based exploration strategy</p>
      </div>

      <section>
        <p>Here's how it works:</p>

        <h3>Stage 1: Base SQL Probes</h3>
        <p>Starting at the tree root, check if target data exists:</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-language">SQL</span>
            <button class="copy-button">Copy</button>
          </div>
          <pre><code class="language-sql">SELECT rental_rate FROM film LIMIT 100;</code></pre>
        </div>

        <h3>Stage 2: Condition SQL Probes</h3>
        <p>Branch from the base and test individual conditions:</p>
        <ol>
          <li>Start from a Base SQL Probe (the root)</li>
          <li>Add column candidates for one specific condition (creating branches)</li>
          <li>Add value candidates for that condition (extending to leaves)</li>
        </ol>
        <p>For example, exploring "films with rating PG":</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-language">SQL</span>
            <button class="copy-button">Copy</button>
          </div>
          <pre><code class="language-sql">-- Branch 1: Test exact match 'PG'
SELECT * FROM film WHERE rating = 'PG' LIMIT 100;

-- Branch 2: Test alternate format 'PG-13'
SELECT * FROM film WHERE rating = 'PG-13' LIMIT 100;

-- Branch 3: Test partial match
SELECT * FROM film WHERE rating LIKE '%PG%' LIMIT 100;</code></pre>
        </div>

        <p>Each path from root to leaf represents a specific Condition SQL Probe. This tree structure ensures comprehensive exploration while avoiding combinatorial explosion.</p>

        <h3>Stage 3: Combination Probes</h3>
        <p>Verify that multiple conditions work together:</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-language">SQL</span>
            <button class="copy-button">Copy</button>
          </div>
          <pre><code class="language-sql">SELECT AVG(rental_rate) FROM film
WHERE rating = 'PG' AND rental_duration > 5;</code></pre>
        </div>

        <p>Each probe returns real data that informs the next decision. The system adapts dynamically to the specific database being queried.</p>
      </section>

      <!-- My Implementation -->
      <section>
        <h2>My Implementation</h2>
        <p>
          I built a full-stack implementation using the <strong>DVD Rental</strong> database. This is a realistic dataset with 15 tables, foreign key relationships, and real-world data quality issues. I wanted to prove this approach could work without vector databases and embedding pipelines.
        </p>
      </section>

      <!-- Tech Stack -->
      <section>
        <h2>Tech Stack</h2>

        <div class="grid md:grid-cols-3 gap-6 my-6">
          <div class="bg-blue-900 p-6 rounded-lg">
            <h3 class="text-blue-200 mb-3">Backend</h3>
            <ul class="space-y-2 text-sm">
              <li>‚Ä¢ FastAPI (Python 3.9+)</li>
              <li>‚Ä¢ PostgreSQL (dvdrental database)</li>
              <li>‚Ä¢ OpenAI GPT-4</li>
              <li>‚Ä¢ LangChain</li>
              <li>‚Ä¢ datasketch for LSH (no embeddings!)</li>
            </ul>
          </div>
          <div class="bg-purple-900 p-6 rounded-lg">
            <h3 class="text-purple-200 mb-3">Frontend</h3>
            <ul class="space-y-2 text-sm">
              <li>‚Ä¢ React 18 + TypeScript</li>
              <li>‚Ä¢ Vite</li>
              <li>‚Ä¢ WebSockets for real-time updates</li>
              <li>‚Ä¢ CSS Custom Properties</li>
            </ul>
          </div>
          <div class="bg-green-900 p-6 rounded-lg">
            <h3 class="text-green-200 mb-3">Architecture</h3>
            <ul class="space-y-2 text-sm">
              <li>‚Ä¢ 4-stage pipeline</li>
              <li>‚Ä¢ Real-time trace visualization</li>
              <li>‚Ä¢ Background async processing</li>
            </ul>
          </div>
        </div>
      </section>

      <!-- The 4-Stage SDE-SQL Pipeline -->
      <section>
        <h2>The 4-Stage SDE-SQL Pipeline</h2>

        <div class="code-block">
          <div class="code-header">
            <span class="code-language">Pipeline Flow</span>
            <button class="copy-button">Copy</button>
          </div>
          <pre><code class="language-text">User Question
   ‚Üì
[Stage 1: Schema Linking]
‚îú‚îÄ Entity Extraction (LLM)
‚îú‚îÄ Value Retrieval (LSH + Fuzzy Match)
‚îî‚îÄ Column Selection (LLM)
   ‚Üì
[Stage 2: Exploration]
‚îú‚îÄ Phase 1: Base Probes (data existence)
‚îú‚îÄ Phase 2: Combination Probes (aggregations)
‚îî‚îÄ LLM analyzes probe results
   ‚Üì
[Stage 3: Generation]
‚îú‚îÄ Self-Consistency (3 candidates)
‚îú‚îÄ Majority voting
‚îî‚îÄ Execute final SQL
   ‚Üì
[Stage 4: Refinement] (if errors)
‚îú‚îÄ SQL decomposition
‚îú‚îÄ Solution exploration
‚îî‚îÄ Target checking
   ‚Üì
Final Results</code></pre>
        </div>
      </section>

      <!-- Why LSH Instead of Embeddings? -->
      <section>
        <h2>Why LSH Instead of Embeddings?</h2>
        <p>
          I used <strong>Locality Sensitive Hashing (LSH)</strong> for value retrieval instead of vector embeddings.
        </p>

        <h3>Traditional RAG approach:</h3>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">Python</span>
            <button class="copy-button">Copy</button>
          </div>
          <pre><code class="language-python"># Expensive and requires external services
embedding = openai.embed("Thomas Hardy")  # API call: $$$
similar = vector_db.search(embedding)      # Infrastructure: $$$</code></pre>
        </div>

        <h3>My SDE-SQL approach:</h3>
        <div class="code-block">
          <div class="code-header">
            <span class="code-language">Python</span>
            <button class="copy-button">Copy</button>
          </div>
          <pre><code class="language-python"># Local, fast, and deterministic
from datasketch import MinHash, MinHashLSH
lsh = MinHashLSH(threshold=0.7, num_perm=128)
matches = lsh.query(create_minhash("Thomas Hardy"))
# Returns: ["Thomas Hardy", "THOMAS HARDY", "thomas hardy"]</code></pre>
        </div>

        <h3>Benefits:</h3>
        <ul>
          <li>No API costs (local algorithm)</li>
          <li>Exact character-level similarity</li>
          <li>Works offline</li>
          <li>Fast O(1) lookup</li>
          <li>No pre-indexing required</li>
          <li>Handles typos and case variations</li>
        </ul>
      </section>

      <!-- Demo: Finding a Customer's Phone Number -->
      <section>
        <h2>Demo: Finding a Customer's Phone Number</h2>
        <p>
          <strong>Question:</strong> "Find the phone number of the customer whose name is Thomas Hardy and who is from UK"
        </p>
        <p>
          This simple query shows the power of active exploration.
        </p>
      </section>

      <div class="my-8">
        <img src="../assets/images/sql-probes/demo1.gif" alt="Execution Demo" class="w-full rounded-lg shadow-lg">
        <p class="text-center text-sm text-secondary mt-2">Real-time execution trace visualization</p>
      </div>

      <section>
        <h3>Execution Trace</h3>

        <div class="bg-gray-800 p-6 rounded-lg my-6">
          <h4 class="font-bold text-white mb-3">Stage 1: Schema Linking (3.2s)</h4>
          <p class="mb-2"><strong>Entities extracted:</strong></p>
          <ul>
            <li>"phone number" ‚Üí TARGET (what to return)</li>
            <li>"customer name is Thomas Hardy" ‚Üí CONDITION</li>
            <li>"customer is from UK" ‚Üí CONDITION</li>
          </ul>
          <p class="mt-4 mb-2"><strong>Selected columns:</strong></p>
          <ul>
            <li>customers.contact_name (character varying)</li>
            <li>customers.country (character varying)</li>
            <li>customers.phone (character varying)</li>
          </ul>
        </div>

        <div class="bg-gray-800 p-6 rounded-lg my-6">
          <h4 class="font-bold text-white mb-3">Stage 2: Exploration (1.8s)</h4>
          <p class="font-semibold mb-3"><em>Phase 1: Candidates Exploration</em></p>

          <p class="font-medium mt-4">Probe: base_1 ‚Äî Explore target column</p>
          <div class="code-block">
            <pre><code class="language-sql">SELECT phone FROM customers LIMIT 100;</code></pre>
          </div>
          <p class="text-sm text-secondary mt-2"><strong>Result:</strong> 91 rows | 0.00ms</p>

          <p class="font-medium mt-4">Probe: cond_1 ‚Äî Test condition: customer name is Thomas Hardy</p>
          <div class="code-block">
            <pre><code class="language-sql">SELECT phone FROM customers
WHERE contact_name = 'Thomas Hardy'
LIMIT 100;</code></pre>
          </div>
          <p class="text-sm text-secondary mt-2"><strong>Result:</strong> 1 row | 0.00ms<br><em>Found exact match for "Thomas Hardy"</em></p>

          <p class="font-medium mt-4">Probe: cond_2 ‚Äî Test condition: customer is from UK</p>
          <div class="code-block">
            <pre><code class="language-sql">SELECT phone FROM customers
WHERE country = 'UK'
LIMIT 100;</code></pre>
          </div>
          <p class="text-sm text-secondary mt-2"><strong>Result:</strong> 7 rows | 0.00ms</p>

          <p class="font-semibold mt-6 mb-3"><em>Phase 2: Combination Exploration</em></p>
          <p class="font-medium">Probe: combo_1</p>
          <div class="code-block">
            <pre><code class="language-sql">SELECT phone FROM customers
WHERE contact_name = 'Thomas Hardy'
  AND country = 'UK'
LIMIT 100;</code></pre>
          </div>
          <p class="text-sm text-secondary mt-2"><strong>Result:</strong> 1 row | 0.00ms</p>
        </div>

        <div class="bg-gray-800 p-6 rounded-lg my-6">
          <h4 class="font-bold text-white mb-3">Stage 3: Generation (1.4s)</h4>
          <p class="mb-2">Self-consistency generated 3 candidates (all identical):</p>
          <div class="code-block">
            <pre><code class="language-sql">SELECT phone FROM customers
WHERE contact_name = 'Thomas Hardy'
  AND country = 'UK';</code></pre>
          </div>
          <p class="mt-4"><strong>Majority Vote:</strong> 100% confidence</p>
          <p class="mt-2"><strong>Result:</strong> (171) 555-1234</p>
        </div>

        <p class="text-lg font-semibold text-green-200 mt-6">
          Success! Total time: 6.4 seconds
        </p>

        <h3 class="mt-8">What the Demo Shows</h3>
        <ol>
          <li>All 4 probes executed in under 1ms</li>
          <li>Discovered exact match for "Thomas Hardy"</li>
          <li>Verified data existence before generation</li>
          <li>100% confidence in final result</li>
          <li>No refinement needed</li>
        </ol>
      </section>

      <!-- Performance and Cost -->
      <section>
        <h2>Performance and Cost</h2>

        <h3>Timing Breakdown:</h3>
        <div class="code-block">
          <pre><code class="language-text">Schema Linking:      3.2s  (50%)
Exploration:         1.8s  (28%)
Generation:          1.4s  (22%)
Refinement:          0.0s  (not needed)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Total:               6.4 seconds</code></pre>
        </div>

        <h3>Cost Analysis (OpenAI GPT-4):</h3>
        <p><strong>Per Query Cost:</strong></p>
        <ul>
          <li>Schema Linking: $0.09 (3 LLM calls)</li>
          <li>Exploration: $0.11 (2‚Äì3 LLM calls)</li>
          <li>Generation: $0.20 (3 candidates via self-consistency)</li>
          <li>Refinement: $0.00 (not triggered)</li>
        </ul>
        <p class="mt-4"><strong>Total: about $0.40 per query</strong></p>
        <p class="text-sm text-secondary mt-2">
          Note: Traditional RAG costs ~$0.06 per query (7x cost increase, but 15% better accuracy)
        </p>
      </section>

      <!-- Success Rate -->
      <section>
        <h2>Success Rate</h2>
        <p>Testing results with 50+ queries on DVD Rental database:</p>
        <ul>
          <li><strong>Simple queries</strong> (single table): 92% success rate, 5‚Äì7 seconds average</li>
          <li><strong>Medium queries</strong> (2‚Äì3 tables): 85% success rate, 8‚Äì12 seconds average</li>
          <li><strong>Complex queries</strong> (4+ tables, aggregations): 78% success rate, 10‚Äì18 seconds average</li>
        </ul>
        <p class="mt-4 text-lg font-semibold text-blue-200">
          Overall: 85% execution accuracy on first attempt
        </p>
      </section>

      <!-- SDE-SQL vs RAG: The Trade-offs -->
      <section>
        <h2>SDE-SQL vs RAG: The Trade-offs</h2>
      </section>

      <div class="my-8">
        <img src="../assets/images/sql-probes/table1.png" alt="SDE-SQL vs RAG Comparison" class="w-full rounded-lg shadow-lg">
        <p class="text-center text-sm text-secondary mt-2">Comprehensive comparison of both approaches</p>
      </div>

      <!-- When to Use Each -->
      <section>
        <h2>When to Use Each</h2>

        <div class="grid md:grid-cols-2 gap-8 my-8">
          <div class="bg-blue-900 p-6 rounded-lg">
            <h3 class="text-blue-200 mb-4">Use RAG when:</h3>
            <ul class="space-y-2">
              <li>‚Ä¢ Speed matters more than accuracy (sub-3 second response time)</li>
              <li>‚Ä¢ High query volume (1000+ queries per day)</li>
              <li>‚Ä¢ Cost-sensitive applications</li>
              <li>‚Ä¢ Simple, well-documented schemas</li>
              <li>‚Ä¢ Mostly single-table queries</li>
            </ul>
          </div>
          <div class="bg-green-900 p-6 rounded-lg">
            <h3 class="text-green-200 mb-4">Use SDE-SQL when:</h3>
            <ul class="space-y-2">
              <li>‚Ä¢ Accuracy is critical (analytics, compliance, reporting)</li>
              <li>‚Ä¢ Complex multi-table queries</li>
              <li>‚Ä¢ Dynamic or poorly documented schemas</li>
              <li>‚Ä¢ Self-service BI tools</li>
              <li>‚Ä¢ You can tolerate 10‚Äì20 second latency</li>
              <li>‚Ä¢ You want to eliminate vector database complexity</li>
            </ul>
          </div>
        </div>
      </section>

      <!-- The Hybrid Approach -->
      <section>
        <h2>The Hybrid Approach</h2>
        <p>The best solution might be using both:</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-language">Python</span>
            <button class="copy-button">Copy</button>
          </div>
          <pre><code class="language-python">complexity = classify_query(question)
if complexity == "simple":
   # Use RAG: fast and cheap
   sql = await rag_generator.generate(question)
else:
   # Use SDE-SQL: accurate
   sql = await sde_pipeline.process(question)</code></pre>
        </div>

        <h3>Result:</h3>
        <ul>
          <li>90% of queries use RAG (average 2 seconds)</li>
          <li>10% use SDE-SQL for complex queries (average 15 seconds)</li>
          <li>Blended cost: about $0.10 per query</li>
          <li>Better accuracy where it matters</li>
        </ul>
      </section>

      <!-- Limitations -->
      <section>
        <h2>Limitations</h2>

        <h3>Latency</h3>
        <p>
          <strong>7‚Äì20 seconds per query</strong> is too slow for user-facing chatbots. Multiple LLM calls and probe executions add overhead.
        </p>

        <h3>Cost</h3>
        <p>
          At <strong>$0.40‚Äì0.60 per query</strong>, costs scale quickly. For 1000+ queries per day: $12,000‚Äì18,000 per month in LLM costs.
        </p>

        <h3>Database Load</h3>
        <p>
          Executing <strong>2‚Äì10 SQL probes per query</strong> increases database load. Could impact performance for high-traffic systems.
        </p>

        <h3>Prompt Dependency</h3>
        <p>
          The system relies heavily on carefully crafted prompts. As noted in the original paper:
        </p>
        <p class="italic text-gray-200 ml-6">
          "The effectiveness of the exploration strategy depends on the quality of prompts used to guide the LLM."
        </p>

        <h3>No Adaptive Learning</h3>
        <p>
          The system can't learn from past successes or failures. Each query starts fresh.
        </p>
        <p class="italic text-gray-200 ml-6">
          "Future work could incorporate reinforcement learning to allow the system to improve over time."
        </p>
      </section>

      <!-- Conclusion -->
      <section>
        <h2>Conclusion</h2>
        <p>
          Sometimes the best solution isn't adding more infrastructure. SQL databases are incredibly fast at answering queries. Why not let the LLM explore the database directly using SQL?
        </p>
        <p>
          This approach won't replace RAG for all use cases. But for complex analytical queries on real-world databases, SQL Probes offer a compelling alternative.
        </p>
        <p>
          The original SDE-SQL paper achieved 68.19% accuracy on the BIRD benchmark. My implementation reached 85% success rate on the DVD Rental database, proving this approach works in practice.
        </p>
        <p>
          <strong>Try SQL Probes for your next Text-to-SQL system. You might be surprised how far you can get without a vector database.</strong>
        </p>
      </section>

      <!-- Try It Yourself -->
      <section class="consulting-cta p-8 md:p-12 rounded-2xl my-12">
        <h2 class="text-white text-center mb-4">Try It Yourself</h2>
        <p class="text-xl text-center mb-8 opacity-90">
          Full source code and examples available on GitHub
        </p>
        <div class="flex justify-center gap-4">
          <a href="https://github.com/MKcodeshere/sde-sql-text2sql" target="_blank" class="btn-primary text-blue-600 hover:bg-gray-800">
            View on GitHub ‚Üí
          </a>
        </div>
        <p class="text-center mt-4 text-sm opacity-75">Setup time: ~5 minutes</p>
      </section>

      <!-- Further Reading -->
      <section>
        <h2>Further Reading</h2>
        <ul>
          <li><strong>Original SDE-SQL Paper:</strong> "Self-Driven Exploration for Text-to-SQL" (arXiv)</li>
          <li><strong>BIRD Benchmark:</strong> A challenging cross-domain Text-to-SQL benchmark</li>
          <li><strong>Implementation Details:</strong> See the GitHub repository for full code and documentation</li>
        </ul>
      </section>

      <!-- Consulting CTA -->
      <div class="consulting-cta">
        <h3>Need Help Implementing This?</h3>
        <p>I offer consulting services for Text-to-SQL systems. Let's discuss your requirements.</p>
        <a href="../consulting.html" class="btn-primary text-blue-600 hover:bg-gray-800">
          Schedule a Consultation
        </a>
      </div>

    </div>
  </div>

  <!-- Footer -->
  <footer>
    <div class="container">
      <div class="grid md:grid-cols-3 gap-8 mb-8">
        <div>
          <h3 class="text-xl font-bold mb-4">Text2SQLHub</h3>
          <p class="text-gray-400">Your comprehensive guide to Text-to-SQL systems with GenAI.</p>
        </div>
        <div class="footer-links">
          <h3 class="text-xl font-bold mb-4">Quick Links</h3>
          <ul class="space-y-2">
            <li><a href="../index.html">Home</a></li>
            <li><a href="../approaches.html">All Approaches</a></li>
            <li><a href="../about.html">About</a></li>
            <li><a href="../consulting.html">Consulting</a></li>
          </ul>
        </div>
        <div>
          <h3 class="text-xl font-bold mb-4">Connect</h3>
          <p class="text-gray-400 text-sm">your@email.com</p>
        </div>
      </div>
      <div class="border-t border-gray-700 pt-6 text-center text-gray-400 text-sm">
        <p>&copy; 2025 Text2SQLHub</p>
      </div>
    </div>
  </footer>

  <!-- Scripts -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
  <script src="../assets/js/main.js"></script>

</body>
</html>
