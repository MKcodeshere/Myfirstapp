<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Building Self-Improving Text-to-SQL Systems with Agentic Context Engineering | Text-to-SQL Handbook</title>

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Custom CSS -->
  <link rel="stylesheet" href="../assets/css/main.css?v=6">

  <!-- Prism.js for code highlighting -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>

  <!-- Navigation -->
  <nav class="navbar">
    <div class="container">
      <div class="flex items-center justify-between py-4">
        <a href="../index.html" class="text-2xl font-bold text-blue-600">
          Text2SQL<span class="text-gray-200">Hub</span>
        </a>
        <div class="hidden md:flex items-center space-x-8">
          <a href="../index.html" class="nav-link">Home</a>
          <a href="../what-is-text2sql.html" class="nav-link">What is Text-to-SQL?</a>
          <a href="../approaches.html" class="nav-link active">Approaches</a>
          <a href="../about.html" class="nav-link">About</a>
          <a href="../consulting.html" class="btn-primary">Get In Touch</a>
        </div>
      </div>
    </div>
  </nav>

  <!-- Article Header -->
  <section class="article-header">
    <div class="container">
      <div class="max-w-4xl mx-auto">
        <a href="../approaches.html" class="text-white opacity-75 hover:opacity-100 mb-6 inline-block">‚Üê Back to All Approaches</a>

        <h1 class="text-3xl md:text-4xl font-bold mb-6">
          Building Self-Improving Text-to-SQL Systems with Agentic Context Engineering
        </h1>

        <!-- Article Meta Info -->
        <div class="article-meta">
          <span>üìÖ January 28, 2025</span>
          <span>‚è±Ô∏è 16 min read</span>
          <span class="difficulty-badge difficulty-advanced">advanced</span>
        </div>
      </div>
    </div>
  </section>

  <!-- Article Content -->
  <div class="container py-12">
    <div class="article-content">

      <!-- Intro -->
      <section>
        <p class="text-xl font-semibold text-gray-200 mb-6">
          Learn to create adaptive database query systems that fix their own mistakes and optimize performance automatically using Stanford's Agentic Context Engineering
        </p>
      </section>

      <!-- Hero Image -->
      <div class="my-8">
        <img src="../assets/images/ace-sql/intro.png" alt="Agentic Context Engineering Introduction" class="w-full rounded-lg shadow-lg">
        <p class="text-center text-sm text-secondary mt-2">Image Generated by Author Using AI</p>
      </div>

      <!-- Introduction -->
      <section>
        <p>
          Most text-to-SQL systems today use multi-agent architectures with monolithic prompts. They generate working queries through complex chains of specialized agents ‚Äî one for schema analysis, another for query planning, a third for SQL generation.
        </p>
        <p>
          These monolithic systems work. They'll turn <strong>"show me top customers"</strong> into executable SQL. But the results are inefficient and frustrating.
        </p>
        <p>
          They use <code>SUBSTRING()</code> when <code>LEFT()</code> runs faster. They write nested subqueries instead of clean JOINs. They crash with PostgreSQL GROUP BY errors that any junior developer spots instantly.
        </p>
        <p>
          The fix is to tweak the prompts for hours. Hope the changes don't break something else and repeat the loop.
        </p>
        <p>
          I built a better approach using Stanford's Agentic Context Engineering (ACE) framework. The system fixes its own mistakes and gets smarter with every query.
        </p>
      </section>

      <!-- Why current solutions fail -->
      <section>
        <h2>Why Current Solutions Fail</h2>
        <p>
          Most teams face an expensive choice. Fine-tune your model or craft better prompts.
        </p>
        <p>
          Fine-tuning costs thousands of dollars and weeks of compute time. You need labeled data, GPU clusters, and model redeployment. One database schema change breaks everything.
        </p>
        <p>
          Prompt engineering seems cheaper but hits two walls:
        </p>
        <ul>
          <li><strong>Brevity bias</strong> makes systems optimize for short prompts that lose important details.</li>
          <li><strong>Context collapse</strong> happens when systems rewrite their knowledge into generic, useless summaries.</li>
        </ul>
        <p>
          Traditional multi-agent systems compound these problems by using monolithic prompts for each agent. When errors occur, you're debugging massive blocks of text across multiple components.
        </p>
        <p>
          ACE takes a different approach. It represents context as structured, itemized bullets rather than single monolithic prompts. Each bullet contains one focused piece of knowledge ‚Äî a schema rule, SQL pattern, or common mistake. This design enables surgical updates instead of wholesale rewrites.
        </p>
        <p>
          The system learns domain expertise in plain English that you can read and modify. Need GDPR compliance? Remove specific rules. Want new business logic? The system learns it from examples.
        </p>
      </section>

      <!-- How ACE works -->
      <section>
        <h2>How ACE Works</h2>
        <p>
          ACE uses three components that work like a software development team:
        </p>
      </section>

      <div class="my-8">
        <img src="../assets/images/ace-sql/architecture.png" alt="ACE Architecture Diagram" class="w-full rounded-lg shadow-lg">
        <p class="text-center text-sm text-secondary mt-2">Image from <a href="https://www.arxiv.org/pdf/2510.04618" target="_blank" class="text-blue-600 hover:underline">Stanford Research Paper</a></p>
      </div>

      <section>
        <ul>
          <li><strong>The Generator</strong> writes SQL queries using current knowledge and database schema information. Think of it as your SQL developer.</li>
          <li><strong>The Reflector</strong> analyzes what went wrong when queries fail or perform poorly. It's your code reviewer that learns patterns across hundreds of failures.</li>
          <li><strong>The Curator</strong> takes those insights and updates the knowledge base using small, targeted changes. It adds new rules, updates counters, and removes outdated advice. The key innovation is incremental delta operations on structured bullet items instead of massive rewrites that lose hard-won knowledge.</li>
        </ul>

        <p class="mt-6">
          Each bullet contains exactly one piece of knowledge:
        </p>
        <ul>
          <li><code>sr-00003: customer.customer_id ‚Üí rental.customer_id (1:N relationship)</code></li>
          <li><code>code-00001: Revenue template using explicit JOINs</code></li>
          <li><code>ts-00002: PostgreSQL requires ALL non-aggregated columns in GROUP BY</code></li>
        </ul>

        <p class="mt-6">
          This granular structure enables surgical updates. When the system learns a new pattern, the Curator adds one bullet. When a rule proves harmful, it deletes just that item. The playbook grows organically without losing existing knowledge.
        </p>

        <h3>Memory Architecture</h3>
        <p>
          The system stores knowledge in three places:
        </p>
        <ul>
          <li><strong>Episodic Memory</strong> logs every query attempt, creating a searchable history of successes and failures</li>
          <li><strong>Semantic Memory</strong> holds database schema, join patterns, and SQL examples in a vector database</li>
          <li><strong>Procedural Memory</strong> maintains the evolving SQL playbook as structured bullet items</li>
        </ul>

        <p class="mt-6">
          The playbook structure prevents context collapse. Instead of one massive prompt that gets rewritten into generic text, ACE maintains hundreds of focused bullets. Each item tracks its own usage statistics and effectiveness scores:
        </p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-language">JSON</span>
            <button class="copy-button">Copy</button>
          </div>
          <pre><code class="language-json">{
  "id": "sr-00001",
  "content": "customer.customer_id ‚Üí rental.customer_id (1:N relationship)",
  "usage_count": 45,
  "helpful": 42,
  "harmful": 3
}</code></pre>
        </div>

        <p class="mt-6">
          This granular tracking enables the system to promote helpful patterns and prune harmful ones without losing everything else.
        </p>
      </section>

      <!-- Real performance gains -->
      <section>
        <h2>Real Performance Gains</h2>
        <p>
          The results prove ACE works. Stanford's evaluation showed <strong>86.9% lower adaptation time</strong> compared to traditional prompt optimization. While methods like GEPA needed over 53,000 seconds and 1,434 attempts to improve, ACE finished the same work in 951 seconds with 238 attempts.
        </p>
        <p>
          ACE matched IBM's top-ranked production agent (powered by GPT-4) using a smaller open-source model. Performance improved <strong>10.6% offline and 8.6% online</strong> without changing a single model parameter.
        </p>
      </section>

      <!-- Building a production-ready system -->
      <section>
        <h2>Building a Production-Ready System</h2>
        <p>
          I built this using the PostgreSQL DVD rental database ‚Äî a DVD rental store with 15 tables, including customer, rental, payment, film, and inventory. This creates realistic complexity with multiple join paths and business logic.
        </p>

        <h3>Architecture Components</h3>
        <p>
          The architecture uses five core components working together:
        </p>

        <ol>
          <li><strong>Memory Fabric</strong> stores knowledge in three layers. Episodic Memory logs every query attempt in PostgreSQL for replay and debugging. Semantic Memory holds schema information, join patterns, and SQL examples in the ChromaDB vector database for fast retrieval. Procedural Memory maintains the evolving playbook as structured JSON.</li>

          <li><strong>Generator</strong> produces SQL using current playbook knowledge plus retrieved schema information via Retrieval-Augmented Generation (RAG). It receives the user query, relevant playbook bullets, and schema metadata to generate executable PostgreSQL.</li>

          <li><strong>Reflector</strong> analyzes outcomes when queries fail or perform poorly. It compares generated SQL against ground truth, identifies error categories like aggregation or join mistakes, and extracts reusable insights.</li>

          <li><strong>Curator</strong> takes reflector insights and surgically updates the playbook using incremental delta operations. Instead of rewriting everything, it adds new rules, updates counters, or removes harmful advice.</li>

          <li><strong>Evaluator</strong> scores SQL quality using rubrics for validity, correctness, efficiency, and safety. Queries scoring above 85% get automatically promoted to update the playbook.</li>
        </ol>

        <div class="bg-blue-900 p-6 rounded-lg my-6">
          <h4 class="font-bold text-blue-300 mb-3">Tech Stack</h4>
          <ul class="space-y-2">
            <li>‚Ä¢ <strong>LangChain</strong> for LLM orchestration</li>
            <li>‚Ä¢ <strong>ChromaDB</strong> for vector storage</li>
            <li>‚Ä¢ <strong>OpenAI GPT-4</strong> for reasoning</li>
            <li>‚Ä¢ <strong>PostgreSQL</strong> for database and episodic memory</li>
            <li>‚Ä¢ <strong>Python</strong> for backend implementation</li>
          </ul>
        </div>
      </section>

      <!-- The system in action -->
      <section>
        <h2>The System in Action</h2>
        <p>
          When someone asks <strong>"Show me top customers by revenue,"</strong> the system:
        </p>

        <ol>
          <li>Retrieves relevant schema knowledge using vector similarity search</li>
          <li>Loads playbook bullets that match the query pattern</li>
          <li>Assembles context within token budgets</li>
          <li>Generates SQL with step-by-step reasoning</li>
          <li>Executes it against the DVD rental database</li>
          <li>Analyzes success or failure for insights</li>
          <li>Updates playbook with delta operations only if required</li>
        </ol>

        <p class="mt-6">
          The playbook starts simple with rules like <code>customer.customer_id ‚Üí rental.customer_id (1:N relationship)</code> and grows into sophisticated patterns like <em>"When calculating customer revenue, always use explicit GROUP BY with all non-aggregated columns to avoid PostgreSQL errors."</em>
        </p>
      </section>

      <!-- Demo: Performance optimization learning -->
      <section>
        <h2>Demo: Performance Optimization Learning</h2>
        <p>
          Here's where the system gets really interesting. A user asks: <strong>"Show me the rentals for each month in the year 2005?"</strong>
        </p>
      </section>

      <div class="my-8">
        <img src="../assets/images/ace-sql/demo.gif" alt="Performance Optimization Demo" class="w-full rounded-lg shadow-lg">
        <p class="text-center text-sm text-secondary mt-2">Real-time learning demonstration</p>
      </div>

      <section>
        <h3>Initial Query (Inefficient)</h3>
        <p>
          The system generates working SQL but uses inefficient patterns:
        </p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-language">SQL</span>
            <button class="copy-button">Copy</button>
          </div>
          <pre><code class="language-sql">SELECT
   EXTRACT(MONTH FROM r.rental_date) AS month,
   COUNT(r.rental_id) AS rental_count
FROM rental r
WHERE EXTRACT(YEAR FROM r.rental_date) = 2005
GROUP BY month
ORDER BY month;</code></pre>
        </div>

        <p class="mt-4">
          This works but performs poorly. The <code>EXTRACT()</code> functions in WHERE and GROUP BY prevent index usage and create unnecessary computation.
        </p>

        <h3>Learning from Feedback</h3>
        <p>
          I provide feedback: <em>"When aggregating by month or year on timestamp columns, use <code>date_trunc</code> for grouping and range filters in WHERE so indexes can be used. Never wrap date columns in EXTRACT/DATE_PART/CAST inside WHERE."</em>
        </p>

        <p class="mt-4">
          The system responds: <strong>"Playbook updated based on your instruction."</strong> The last update time changes from 12:12 to 12:14, indicating the update in the SQL playbook.
        </p>

        <h3>Optimized Query (After Learning)</h3>
        <p>
          When I ask the same question again, it generates optimized SQL:
        </p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-language">SQL</span>
            <button class="copy-button">Copy</button>
          </div>
          <pre><code class="language-sql">SELECT
   date_trunc('month', r.rental_date) AS rental_month,
   COUNT(*) AS rental_count
FROM rental r
WHERE r.rental_date >= '2005-01-01' AND r.rental_date < '2006-01-01'
GROUP BY rental_month
ORDER BY rental_month;</code></pre>
        </div>

        <p class="mt-4">
          The Curator added a new bullet to the playbook: <code>ts-00008: Use date_trunc for time grouping and range filters for WHERE clauses to enable index usage.</code>
        </p>

        <p class="mt-4 text-lg font-semibold text-green-200">
          This learning applies to all future date-based queries. The system builds performance optimization knowledge through real usage.
        </p>
      </section>

      <!-- Continuous improvement -->
      <section>
        <h2>Continuous Improvement</h2>
        <p>
          The real breakthrough is the nightly learning cycle. The system replays recent failures with different playbook versions using Thompson sampling to find what actually works better. Successful changes get promoted to production automatically.
        </p>
        <p>
          This creates a text-to-SQL system that improves with use. Not through expensive retraining, but through accumulated real-time curated instructions. More queries make it smarter.
        </p>
      </section>

      <!-- What this means for text-to-SQL systems -->
      <section>
        <h2>What This Means for Text-to-SQL Systems</h2>
        <p>
          This approach transforms how organizations handle database queries. Traditional text-to-SQL systems require constant maintenance ‚Äî tweaking prompts, updating examples, retraining models when schemas change.
        </p>
        <p>
          ACE-based systems become more valuable over time through accumulated wisdom. Every failed query teaches the system something new. Every performance optimization gets encoded as reusable knowledge.
        </p>

        <h3>Cost Benefits</h3>
        <p>
          The cost benefits are substantial. My implementation reduces adaptation time by <strong>86.9%</strong> compared to traditional prompt optimization methods. Where other systems need hundreds of expensive LLM calls to improve, ACE achieves better results with surgical updates to specific knowledge items.
        </p>

        <h3>Organizational Learning at Scale</h3>
        <p>
          More importantly, the system enables organizational learning at scale. Database administrators can focus on schema design instead of prompt engineering. Domain experts can contribute business rules through natural feedback rather than technical prompts. The knowledge base becomes a living asset that captures institutional wisdom.
        </p>
        <p>
          Consider regulatory compliance scenarios. When GDPR requires removing customer data references, you delete specific playbook bullets rather than retraining entire models. When new business rules emerge, the system learns them organically from query patterns and feedback.
        </p>

        <h3>The Fundamental Shift</h3>
        <p>
          The implications extend beyond SQL generation. We're moving toward AI systems that truly adapt to their environments rather than requiring expensive retraining cycles. These systems become colleagues that understand your domain's nuances, your team's preferences, and your organization's constraints.
        </p>
        <p>
          The fundamental shift is from static AI that degrades over time to adaptive AI that improves with use. Your text-to-SQL system doesn't just translate language to queries ‚Äî it builds institutional knowledge that compounds with every interaction.
        </p>
      </section>

      <!-- Try It Yourself -->
      <section class="consulting-cta p-8 md:p-12 rounded-2xl my-12">
        <h2 class="text-white text-center mb-4">Try It Yourself</h2>
        <p class="text-xl text-center mb-8 opacity-90">
          Want to see ACE in action? The complete implementation is available on GitHub with setup instructions for the PostgreSQL dvdrental database.
        </p>
        <div class="flex justify-center gap-4">
          <a href="https://github.com/MKcodeshere/Self-Improving-Text2SQL/tree/main" target="_blank" class="btn-primary text-blue-600 hover:bg-gray-800">
            View on GitHub ‚Üí
          </a>
        </div>
        <p class="text-center mt-6 text-sm opacity-90">
          In the next part, I will cover how knowledge bases like Episodic, Semantic, and Procedural will benefit the Text2SQL systems with the ACE framework
        </p>
      </section>

      <!-- Resources -->
      <section>
        <h2>Resources</h2>
        <ul>
          <li><strong>Stanford Research Paper:</strong> <a href="https://www.arxiv.org/pdf/2510.04618" target="_blank" class="text-blue-600 hover:underline">Agentic Context Engineering</a></li>
          <li><strong>GitHub Repository:</strong> <a href="https://github.com/MKcodeshere/Self-Improving-Text2SQL/tree/main" target="_blank" class="text-blue-600 hover:underline">Self-Improving Text2SQL Implementation</a></li>
        </ul>
      </section>

      <!-- Consulting CTA -->
      <div class="consulting-cta">
        <h3>Need Help Implementing This?</h3>
        <p>I offer consulting services for Text-to-SQL systems. Let's discuss your requirements.</p>
        <a href="../consulting.html" class="btn-primary text-blue-600 hover:bg-gray-800">
          Schedule a Consultation
        </a>
      </div>

    </div>
  </div>

  <!-- Footer -->
  <footer>
    <div class="container">
      <div class="grid md:grid-cols-3 gap-8 mb-8">
        <div>
          <h3 class="text-xl font-bold mb-4">Text2SQLHub</h3>
          <p class="text-gray-400">Your comprehensive guide to Text-to-SQL systems with GenAI.</p>
        </div>
        <div class="footer-links">
          <h3 class="text-xl font-bold mb-4">Quick Links</h3>
          <ul class="space-y-2">
            <li><a href="../index.html">Home</a></li>
            <li><a href="../approaches.html">All Approaches</a></li>
            <li><a href="../about.html">About</a></li>
            <li><a href="../consulting.html">Consulting</a></li>
          </ul>
        </div>
        <div>
          <h3 class="text-xl font-bold mb-4">Connect</h3>
          <p class="text-gray-400 text-sm">your@email.com</p>
        </div>
      </div>
      <div class="border-t border-gray-700 pt-6 text-center text-gray-400 text-sm">
        <p>&copy; 2025 Text2SQLHub</p>
      </div>
    </div>
  </footer>

  <!-- Scripts -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
  <script src="../assets/js/main.js"></script>

</body>
</html>
